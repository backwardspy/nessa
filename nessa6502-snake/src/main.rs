use color_eyre::Result;
use nessa6502::cpu::CPU;
use nessa6502_disasm::disassemble_instruction;
use pyxel::PyxelCallback;
use tracing::trace;

struct App {
    cpu: CPU,
    started: bool,
}

impl App {
    fn new() -> Self {
        let code = &[
            0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9,
            0x02, 0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85,
            0x12, 0xa9, 0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60,
            0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe, 0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60,
            0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20,
            0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9,
            0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60, 0xa9, 0x04,
            0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
            0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04,
            0x85, 0x02, 0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60,
            0x60, 0x20, 0x94, 0x06, 0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d,
            0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60,
            0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09,
            0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c, 0x35, 0x07, 0x60, 0xa6,
            0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0,
            0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
            0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28,
            0x60, 0xe6, 0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69,
            0x20, 0x85, 0x10, 0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c,
            0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35,
            0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60, 0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10,
            0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea, 0xea, 0xca, 0xd0, 0xfb,
            0x60,
        ];

        let mut cpu = CPU::new();
        cpu.load(code, 0x0600);
        cpu.reset();

        Self {
            cpu,
            started: false,
        }
    }

    fn step(&mut self) {
        let disasm =
            disassemble_instruction(self.cpu.mem[self.cpu.reg.pc as usize..].iter().copied())
                .expect("disassemble_instruction failed");
        trace!(
            "{:04X}| {disasm: <24} a:{:02X} x:{:02X} y:{:02X} sp:{:02X} p:{:08b}",
            self.cpu.reg.pc,
            self.cpu.reg.a,
            self.cpu.reg.x,
            self.cpu.reg.y,
            self.cpu.reg.sp,
            self.cpu.reg.status,
            disasm = disasm
        );

        if let Err(e) = self.cpu.step() {
            tracing::error!(?e);
            pyxel::quit();
        }

        if !self.cpu.is_running {
            tracing::info!("CPU halted");
            pyxel::quit();
        }
    }
}

impl PyxelCallback for App {
    fn update(&mut self) {
        if !self.started {
            if pyxel::btnp(pyxel::KEY_SPACE, None, None) {
                self.started = true;
            } else {
                return;
            }
        }

        if pyxel::btnp(pyxel::KEY_W, None, None) {
            self.cpu.mem[0xFF] = 0x77;
        } else if pyxel::btnp(pyxel::KEY_D, None, None) {
            self.cpu.mem[0xFF] = 0x64;
        } else if pyxel::btnp(pyxel::KEY_S, None, None) {
            self.cpu.mem[0xFF] = 0x73;
        } else if pyxel::btnp(pyxel::KEY_A, None, None) {
            self.cpu.mem[0xFF] = 0x61;
        }

        for _ in 0..200 {
            self.cpu.mem[0xFE] = pyxel::rndi(0, 256).to_le_bytes()[0];
            self.step();
        }
    }

    fn draw(&mut self) {
        pyxel::cls(0);

        for y in 0..32 {
            for x in 0..32 {
                let addr = 0x200 + y * 32 + x;
                let c = self.cpu.mem[addr];
                if self.cpu.mem[addr] > 0 {
                    pyxel::pset(x as f64, y as f64, 1 + (c % 15));
                }
            }
        }

        if !self.started {
            pyxel::text(0.0, 0.0, "Press SPACE to start", 7);
        }
    }
}

fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .without_time()
        .with_max_level(tracing::Level::TRACE)
        .init();

    let app = App::new();
    pyxel::init(
        32,
        32,
        Some("nessa6502 snake"),
        Some(30),
        Some(pyxel::KEY_Q),
        Some(8),
        None,
        None,
    );
    pyxel::run(app);

    Ok(())
}
